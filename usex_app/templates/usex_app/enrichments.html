{% extends "usex_app/index.html" %}
{% block title %}
Parser - Matcha
{% endblock %}
{% block style %}
<!-- Awesomplete CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/awesomplete/1.1.5/awesomplete.min.css">

<!-- Awesomplete JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/awesomplete/1.1.5/awesomplete.min.js"></script>


<style>
    .btn-link {
        text-decoration: none;
        color: #007bff;
    }

    .btn-link:hover {
        text-decoration: underline;
    }

    .bi-chevron-down {
        transition: transform 0.3s ease;
    }

    .collapse.show + .card-header .bi-chevron-down {
        transform: rotate(180deg); /* Rotate arrow when expanded */
    }
</style>
<style>
    .card-body {
        min-height: 400px; /* Set minimum height for scrollable areas */
        max-height: 400px; /* Set maximum height for scrollable areas */
        overflow-y: auto; /* Enable vertical scrolling */
    }

    .datatype-box {
        display: inline-block;
        padding: 2px 6px;
        margin-left: 8px;
        border-radius: 4px;
        font-size: 0.85em;
        font-style: italic;
        color: white; /* Default text color */
    }

    .str {
        background-color: #007bff; /* Blue for strings */
    }

    .int {
        background-color: #28a745; /* Green for integers */
    }

    .float {
        background-color: #ffc107; /* Yellow for floats */
    }

    .bool {
        background-color: #17a2b8; /* Teal for booleans */
    }

    .datetime {
        background-color: #6c757d; /* Grey for dates */
    }
</style>
{% endblock %}

{% block content %}

<div class="container mt-4">
    <h2>Enrichment for {{ datasource.name }}</h2>
    <p> {{ datasource.description }}</p>
    <p><strong>Type:</strong> {{ datasource.datasource_type }}</p>

    <div class="row">
        <!-- Left Column: Query Result Columns -->
        <div class="col-md-3" style="max-height: 400px; overflow-y: auto;">
            <div class="card">
                <div class="card-header">
                    <h5>Parsing schema</h5>
                </div>
                <div class="card-body" style="max-height: 300px; overflow-y: auto;">
                    <ul id="query-columns" class="list-group">
                        <!-- Dynamically populated list of columns -->
                    </ul>
                </div>
            </div>
            <!-- Lookup Datastore Section -->
            
        <div class="card mt-4">
            <div class="card-header">
                <h5>Lookup Datastore</h5>
            </div>
            <div class="card-body" style="max-height: 300px; overflow-y: auto;">
                <ul id="lookup-datastores" class="list-group">
                    <!-- Dynamically populated list of datastores -->
                </ul>
            </div>
        </div>
        </div>
        
        <!-- Middle Column: Calculation Field Area -->
        <div class="col-md-6">
            <div id="calculated-field-area" class="card mb-4">
                <div class="card-header">
                    <h5>Create Calculated Field</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <!-- Left Column: Scrollable Operations Menu -->
                        <div class="col-md-4">
                            <div class="mb-3" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px;">
                                <label class="form-label">Select Operation</label>
                                <div id="operations-menu" class="accordion" role="tablist">
                                    <!-- Dynamically populated collapsible list -->
                                </div>
                            </div>
                        </div>

                        <!-- Middle Column: Operation Details -->
                        <div class="col-md-4">
                            <div id="operation-details" class="mt-3">
                                <h6>Operation Details</h6>
                                <p id="operation-description"><strong>Description:</strong> <span></span></p>
                                <p id="operation-example"><strong>Example:</strong> <span></span></p>
                            </div>
                        </div>

                        <!-- Right Column: Field Name and Expression -->
                        <div class="col-md-4">
                            <form id="calculated-field-form">
                                <div class="mb-3">
                                    <label for="field-name" class="form-label">Field Name</label>
                                    <input type="text" id="field-name" class="form-control" placeholder="Enter field name" required>
                                </div>
                                <div class="mb-3">
                                    <label for="field-expression" class="form-label">Field Expression</label>
                                    <textarea id="field-expression" class="form-control awesomplete" rows="3" data-multiple placeholder="Drag and drop column names here or type manually" required></textarea>
                                </div>
                                <button type="button" id="save-calculated-field" class="btn btn-primary">Save Field</button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Column: Created Fields -->
        <div class="col-md-3">
            <div class="card">
                <div class="card-header">
                    <h5>Enrichment Schema</h5>
                </div>
                <div id='created-fields-body' class="card-body" style="max-height: 400px; overflow-y: auto;">
                    <ul id="created-fields" class="list-group">
                        <!-- Dynamically populated list of created fields -->
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="schemaDifferenceModal" tabindex="-1" aria-labelledby="schemaDifferenceModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="schemaDifferenceModalLabel">Schema Difference</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <h6>Stored Schema:</h6>
                <pre id="stored-schema-display" style="background-color: #f8f9fa; padding: 10px; border-radius: 5px;"></pre>
                <h6>Current Schema:</h6>
                <pre id="current-schema-display" style="background-color: #f8f9fa; padding: 10px; border-radius: 5px;"></pre>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" id="update-schema-button" class="btn btn-primary">Update Schema</button>
            </div>
        </div>
    </div>
</div>
<div class="container mt-5">
    
    <div>
        <input type="checkbox" id="set-rejection-criteria" />
        <label for="set-rejection-criteria">Set Rejection Criteria on lookup</label>
    </div>
    <div id="rejection-criteria-container" style="display: none; margin-top: 10px;">
        <label for="input-schema-dropdown">Select Field:</label>
        <select id="input-schema-dropdown" class="form-control">
            <!-- Options will be dynamically populated -->
        </select>
        <button id="set-rejection-button" class="btn btn-primary mt-2">Set Condition</button>
    </div>
    <!-- Skip Campaign Processing Checkbox -->
    <div class="mt-3">
        <input type="checkbox" id="skip-campaign-processing" />
        <label for="skip-campaign-processing">Skip Campaign Processing</label>
    </div>
</div>

<script>
    
    document.addEventListener('DOMContentLoaded', function () {
        const queryColumns = document.getElementById('query-columns');
        const columnDatatypes = document.getElementById('column-datatypes');
        const firstRecordValues = document.getElementById('first-record-values');
        const createdFields = document.getElementById('created-fields');
        const createdFieldsBody = document.getElementById('created-fields-body');
        
        const saveCalculatedFieldButton = document.getElementById('save-calculated-field');
        const fieldNameInput = document.getElementById('field-name');
        const fieldExpressionInput = document.getElementById('field-expression');

        // Function to fetch query dataset from the backend
        async function fetchParsingDataset() {
            try {
                const response = await fetch("{% url 'fetch_query_dataset' datasource.id %}", {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Error: ${response.statusText}`);
                }

                const data = await response.json();
                if (data.success) {
                    return data; // Return the dataset
                } else {
                    alert(`Error: ${data.error}`);
                    return null;
                }
            } catch (error) {
                console.error('Error fetching query dataset:', error);
                alert('Failed to fetch query dataset. Please try again.');
                return null;
            }
        }
        let dataset = null;
        // Handle "Get Input Schema" button click
        let relationships =null;
        
        
        async function fetchLookupDatastores_init() {
            try {
                const response = await fetch(`{% url 'get_relationships' %}?datasource_id={{ datasource.id }}`, {
                    method: 'GET',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                    },
                });
    
                if (!response.ok) {
                    throw new Error(`Error: ${response.statusText}`);
                }
    
                const data = await response.json();
                if (data.success && data.relationships.length > 0) {
                    relationships =  data.relationships; // Return relationships for dropdown population
                } else {
                    relationships = [];
                    throw new Error(`Error: ${data.error}`);
                }
            } catch (error) {
                console.error('Error fetching lookup datastores:', error);
                alert('Failed to fetch query dataset. Please try again.');
                return [];
                
            }
        }
        
        async function getParsingSchema() {
            // Fetch query dataset
            dataset = await fetchParsingDataset();

            if (!dataset) return;

            
            
            // Populate the query columns list
            queryColumns.innerHTML = '';
            Object.entries(dataset.parsing_schema).forEach(([column,column_data]) => {
                const li = document.createElement('li');
                li.className = 'list-group-item draggable';
                li.textContent = column;
                li.draggable = true;
                

                // Add drag-and-drop functionality
                li.addEventListener('dragstart', function (event) {
                    const columnData = {
                        name: column,
                        datatype: column_data['datatype'],
                        value: column_data['result'],
                        formula:'$feed.'+column
                    };
                    event.dataTransfer.setData('application/json', JSON.stringify(columnData)); // Set data as JSON
                });
                li.addEventListener('dblclick', function () {
                    fieldExpressionInput.value += '$feed.'+column ;
                });
                li.innerHTML = `<span class="datatype-box ${column_data['datatype'].toLowerCase()}">${column_data['datatype']}</span> 
                                <strong>${column}</strong> 
                                <span style="font-size: 0.9em; font-style: italic; color: grey;">(Ex: ${column_data['result']})</span>`;

                queryColumns.appendChild(li);
            });
            // Populate the "Created Fields" list based on enrichment_schema
    createdFields.innerHTML = ''; // Clear existing fields
    const enrichmentSchema = dataset.enrichment_schema || {};
    console.log("Pre-enrichment schema:", enrichmentSchema);
    Object.entries(enrichmentSchema).forEach(([fieldName, fieldData]) => {
        const { formula, result, datatype,storeback_table } = fieldData;

        // Add the field to the "Created Fields" list
        addFieldToCreatedFields(fieldName, formula, datatype, result,storeback_table);
    });

          
            
        }
        async function initializePage() {
            await fetchLookupDatastores_init(); // Ensure relationships is populated
            getParsingSchema(); // Call getParsingSchema after relationships is populated
        }
        
        initializePage();
        function addFieldToCreatedFields(fieldName, fieldExpression, fieldDatatype, fieldValue,storeback_table='') {
            console.debug("Adding field:", fieldName, fieldExpression, fieldDatatype, fieldValue, storeback_table);
            const li = document.createElement('li');
            li.className = 'list-group-item d-flex justify-content-between align-items-center';
            li.dataset.formula = fieldExpression; // Store the formula in a data attribute
        
            li.innerHTML = `
                <div>
                    <span class="datatype-box ${fieldDatatype.toLowerCase()}">${fieldDatatype}</span>
                    <strong>${fieldName}</strong>: ${fieldExpression} 
                    <span style="font-size: 0.9em; font-style: italic; color: grey;">(Result: ${fieldValue})</span>
                </div>
                <button class="btn btn-danger btn-sm delete-field-btn" title="Delete Field">
                    <i class="fas fa-trash"></i>
                </button>
                <select class="form-select datastore-dropdown" data-field-name="${fieldName}">
                    <option value="">Select Datastore</option>
                    ${relationships.map(relationship => `
                        <option value="${relationship.datastore_internal_name}" ${storeback_table === relationship.datastore_internal_name ? 'selected' : ''}>
                            ${relationship.datastore_name}
                        </option>
                    `).join('')}
                </select>
            `;
            // Add change event listener to the dropdown
            li.querySelector('.datastore-dropdown').addEventListener('change', async function () {
                const selectedDatastore = this.value;
                const fieldName = this.dataset.fieldName;

                try {
                    const response = await fetch(`{% url 'update_storeback_datastore' %}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}',
                        },
                        body: JSON.stringify({
                            field_name: fieldName,
                            storeback_table: selectedDatastore,
                            datasource_id: '{{ datasource.id }}',
                        }),
                    });

                    if (!response.ok) {
                        throw new Error(`Error: ${response.statusText}`);
                    }

                    const data = await response.json();
                    if (data.success) {
                        alert(`Storeback updated for field "${fieldName}" to datastore "${selectedDatastore}".`);
                    } else {
                        alert(`Error updating storeback: ${data.error}`);
                    }
                } catch (error) {
                    console.error('Error updating storeback:', error);
                    alert('Failed to update storeback. Please try again.');
                }
            });

            
    
            // Add delete functionality
            li.querySelector('.delete-field-btn').addEventListener('click', async function () {
                const confirmDelete = confirm(`Are you sure you want to delete the field "${fieldName}"?`);
                if (confirmDelete) {
                    try {
                        // Send request to delete the field from enrichment_schema
                        const response = await fetch("{% url 'delete_enrichment_field' datasource.id %}", {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ field_name: fieldName })
                        });
        
                        if (!response.ok) {
                            throw new Error(`Error: ${response.statusText}`);
                        }
        
                        const data = await response.json();
                        if (data.success) {
                            // Remove the field from the UI
                            li.remove();
                            alert(`Field "${fieldName}" deleted successfully.`);
                            location.reload(); // Reload the page to reflect changes
                            // Disable the calculated field inputs if the deleted field is currently being edited
                if (fieldNameInput.value === fieldName) {
                    fieldNameInput.value = '';
                    fieldExpressionInput.value = '';
                    fieldNameInput.disabled = true;
                    fieldExpressionInput.disabled = true;

                    // Reset the "Save Field" button
                    saveCalculatedFieldButton.textContent = "Save Field";
                    saveCalculatedFieldButton.classList.add("btn-primary");
                    saveCalculatedFieldButton.classList.remove("btn-warning");
                }
                        } else {
                            alert(`Error deleting field: ${data.error}`);
                        }
                    } catch (error) {
                        console.error('Error deleting field:', error);
                        alert('Failed to delete field. Please try again.');
                    }
                }
            });
        
            createdFields.appendChild(li);
        }

        // Enable drag-and-drop for the "Created Fields" list
        createdFieldsBody.addEventListener('dragover', function (event) {
            event.preventDefault(); // Allow dropping
        });
        
        createdFieldsBody.addEventListener('drop', async function (event) {
            event.preventDefault(); // Prevent default behavior
        
            // Get the dropped data as JSON
            const droppedData = JSON.parse(event.dataTransfer.getData('application/json'));
        
            // Extract column name, datatype, and value
            const fieldName = droppedData.name;
            const fieldDatatype = droppedData.datatype;
            const fieldValue = droppedData.value;
            const fieldExpression = droppedData.formula; // Simple formula using the column name
            console.debug("Dropped Data:", droppedData);
        
            // Check if the field name already exists in the "Created Fields" list
            const existingField = Array.from(createdFields.children).find(
                (item) => item.querySelector('strong').textContent === fieldName
            );
        
            if (existingField) {
                alert(`Field name "${fieldName}" already exists. Please choose a different name.`);
                return;
            }
        
            try {
                // Send the formula data to the backend to update the enrichment_schema
                const response = await fetch("{% url 'update_enrichment_schema' datasource.id %}", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: JSON.stringify({
                        field_name: fieldName,
                        formula: fieldExpression,
                        result: fieldValue,
                        datatype: fieldDatatype
                    })
                });
        
                if (!response.ok) {
                    throw new Error(`Error: ${response.statusText}`);
                }
        
                const data = await response.json();
        
                if (data.success) {
                    // Add the new field to the "Created Fields" list
                    console.debug("Field adding:", fieldName, fieldExpression, fieldDatatype, fieldValue);
                    addFieldToCreatedFields(fieldName, fieldExpression, fieldDatatype, fieldValue)
                    console.debug("Field added:", fieldName, fieldExpression, fieldDatatype, fieldValue);
                } else {
                    alert(`Error: ${data.error}`);
                }
            } catch (error) {
                console.error('Error updating enrichment_schema:', error);
                alert('Failed to update enrichment_schema. Please try again.');
            }
        });

        // Enable drag-and-drop for the field expression textarea
        fieldExpressionInput.addEventListener('dragover', function (event) {
            event.preventDefault();
        });

        fieldExpressionInput.addEventListener('drop', function (event) {
            event.preventDefault();
            const droppedText = event.dataTransfer.getData('text/plain');
            fieldExpressionInput.value += droppedText;
        });

        // Handle "Save Calculated Field" button click
                
        saveCalculatedFieldButton.addEventListener('click', async function () {
            const fieldName = fieldNameInput.value.trim();
            const fieldExpression = fieldExpressionInput.value.trim();
            const columnValues = {}
            console.debug("Dataset:", dataset);
            console.debug('relationships:', relationships);
            Object.entries(dataset.parsing_schema).forEach(([column,column_data]) => {
                //console.debug("Column Data:", column_data);
                //console.debug("Column:", column);
                columnValues['$feed.'+column] = column_data['result']; // Assuming dataset contains column values
            });
            relationships.forEach(relationship => {
                console.log(`Datastore Name: ${relationship.datastore_name}`);
                //console.log(`Datastore Key: ${relationship.datastore_key}`);
                
                // Loop through columns in the relationship
                relationship.columns.forEach(column => {
                    console.log(`Column Name: ${column.name}`);
                    console.log(`Column Datatype: ${column.data.datatype}`);
                    console.log(`Column Value: ${column.data.result}`);
                    columnValues[`$profile.${relationship.datastore_internal_name.toLowerCase()}.`+column.name] = column.data.result; // Assuming dataset contains column values
                });
            });
            const mode = saveCalculatedFieldButton.textContent === "Update Field" ? "update" : "create";
        
            if (!fieldName || !fieldExpression) {
                alert('Both field name and expression are required.');
                return;
            }
        
            if (mode !== "update") {
                // Check if the field name already exists in the "Created Fields" list
                const existingField = Array.from(createdFields.children).find(
                    (item) => item.querySelector('strong').textContent === fieldName
                );
        
                if (existingField) {
                    alert(`Field name "${fieldName}" already exists. Please choose a different name.`);
                    return;
                }
            }
        
            // Prepare the payload with field expression and column values
            const payload = {
                field_expression: fieldExpression,
                column_values: columnValues // Assuming dataset contains column values
            };
        
            try {
                // Send the payload to the API
                const response = await fetch("{% url 'formula_interpreter_api' %}", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: JSON.stringify(payload)
                });
        
                if (!response.ok) {
                    throw new Error(`Error: ${response.statusText}`);
                }
        
                const data = await response.json();
                if (data.success) {
                    // Extract the returned value and datatype
                    const calculatedValue = data.result.value;
                    const calculatedDatatype = data.result.datatype;
        
                    if (mode === "update") {
                        // Update the existing field in the "Created Fields" list
                        const existingField = Array.from(createdFields.children).find(
                            (item) => item.querySelector('strong').textContent === fieldName
                        );
        
                        if (existingField) {
                            existingField.dataset.formula = fieldExpression; // Update the formula in the dataset
                            existingField.innerHTML = `
                                <div>
                                    <span class="datatype-box ${calculatedDatatype.toLowerCase()}">${calculatedDatatype}</span>
                                    <strong>${fieldName}</strong>: ${fieldExpression} 
                                    <span style="font-size: 0.9em; font-style: italic; color: grey;">(Result: ${calculatedValue})</span>
                                </div>
                                <button class="btn btn-danger btn-sm delete-field-btn" title="Delete Field">
                                    <i class="fas fa-trash"></i>
                                </button>
                            `;
                        }
                        // Add delete functionality
                        existingField.querySelector('.delete-field-btn').addEventListener('click', async function () {
                const confirmDelete = confirm(`Are you sure you want to delete the field "${fieldName}"?`);
                if (confirmDelete) {
                    try {
                        // Send request to delete the field from enrichment_schema
                        const response = await fetch("{% url 'delete_enrichment_field' datasource.id %}", {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ field_name: fieldName })
                        });
        
                        if (!response.ok) {
                            throw new Error(`Error: ${response.statusText}`);
                        }
        
                        const data = await response.json();
                        if (data.success) {
                            // Remove the field from the UI
                            existingField.remove();
                            alert(`Field "${fieldName}" deleted successfully.`);
                            // Disable the calculated field inputs if the deleted field is currently being edited
                if (fieldNameInput.value === fieldName) {
                    fieldNameInput.value = '';
                    fieldExpressionInput.value = '';
                    fieldNameInput.disabled = true;
                    fieldExpressionInput.disabled = true;

                    // Reset the "Save Field" button
                    saveCalculatedFieldButton.textContent = "Save Field";
                    saveCalculatedFieldButton.classList.add("btn-primary");
                    saveCalculatedFieldButton.classList.remove("btn-warning");
                }
                        } else {
                            alert(`Error deleting field: ${data.error}`);
                        }
                    } catch (error) {
                        console.error('Error deleting field:', error);
                        alert('Failed to delete field. Please try again.');
                    }
                }
            });
                    } else {
                        // Add the new field to the "Created Fields" list
                        addFieldToCreatedFields(fieldName, fieldExpression, calculatedDatatype, calculatedValue);
                    }
        
                    // Send the formula data to the backend to update the enrichment_schema
                    const updateResponse = await fetch("{% url 'update_enrichment_schema' datasource.id %}", {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({
                            field_name: fieldName,
                            formula: fieldExpression,
                            result: calculatedValue,
                            datatype: calculatedDatatype
                        })
                    });
        
                    if (!updateResponse.ok) {
                        throw new Error(`Error: ${updateResponse.statusText}`);
                    }
        
                    const updateData = await updateResponse.json();
        
                    if (!updateData.success) {
                        alert(`Error updating enrichment_schema: ${updateData.error}`);
                    }
        
                    // Clear the form inputs
                    fieldNameInput.value = '';
                    fieldExpressionInput.value = '';
                } else {
                    alert(`Error: ${data.error}`);
                }
            } catch (error) {
                console.error('Error saving calculated field:', error);
                alert('Failed to save calculated field. Please try again.');
            }
        
            if (mode === "update") {
                // Reset the button to "Save" mode
                saveCalculatedFieldButton.textContent = "Save Field";
                saveCalculatedFieldButton.classList.add("btn-primary");
                saveCalculatedFieldButton.classList.remove("btn-warning");
            }
        });
        createdFields.addEventListener('click', function (event) {
            const clickedItem = event.target.closest('.list-group-item'); // Get the clicked list item
            if (clickedItem) {
                const fieldName = clickedItem.querySelector('strong').textContent; // Extract the field name
                const fieldFormula = clickedItem.dataset.formula; // Extract the formula stored in the dataset
        
                // Populate the calculated area inputs
                fieldNameInput.value = fieldName;
                fieldExpressionInput.value = fieldFormula;
        
                // Switch the button to "Update" mode
                saveCalculatedFieldButton.textContent = "Update Field";
                saveCalculatedFieldButton.classList.add("btn-warning"); // Change button style to indicate update
                saveCalculatedFieldButton.classList.remove("btn-primary");
        
                
            }
        });
    });
    // Handle clicks on created fields

    
    document.addEventListener('DOMContentLoaded', async function () {
        const operationsMenu = document.getElementById('operations-menu');
        const operationDescription = document.getElementById('operation-description').querySelector('span');
        const operationExample = document.getElementById('operation-example').querySelector('span');
        const fieldExpressionInput = document.getElementById('field-expression');
        const operationsData = await fetch('/api/get_operations').then(response => response.json());
        // Example operations data (replace this with data fetched from the backend)
        const operationsData1 = {
            string: [
                {
                    name: "Concatenate",
                    description: "Combine two or more strings.",
                    formula_keyword: "CONCATENATE",
                    example: "concatenate(col1, ' ', col2)"
                },
                {
                    name: "Substring",
                    description: "Extract a portion of a string.",
                    formula_keyword: "SUBSTRING",
                    example: "substring(col1, 0, 5)"
                }
            ],
            integer: [
                {
                    name: "Add",
                    description: "Add two integers.",
                    formula_keyword: "ADD",
                    example: "add(col1, col2)"
                },
                {
                    name: "Subtract",
                    description: "Subtract one integer from another.",
                    formula_keyword: "SUBTRACT",
                    example: "subtract(col1, col2)"
                }
            ]
            // Add more datatypes and operations here
        };
        // Collect all formula keywords for autocomplete
        const formulaKeywords = [];
        for (const operations of Object.values(operationsData)) {
            operations.forEach(operation => {
                formulaKeywords.push(operation.formula_keyword);
            });
        }
        // Initialize Awesomplete
        new Awesomplete(fieldExpressionInput, {
            list: formulaKeywords, // Provide the list of keywords
            minChars: 1, // Start suggesting after 1 character
            autoFirst: true, // Automatically highlight the first suggestion
            filter: function(text, input) {
                return Awesomplete.FILTER_CONTAINS(text, input.match(/[^\(]*$/)[0]);
            },
        
            item: function(text, input) {
                return Awesomplete.ITEM(text, input.match(/[^\(]*$/)[0]);
            },
        
            replace: function(text) {
                var before = this.input.value.match(/^.+\(\s*|/)[0];
                this.input.value = before + text + "( ";
                
            }
        });
        // Populate the collapsible operations menu
        for (const [datatype, operations] of Object.entries(operationsData)) {
            const datatypeId = `datatype-${datatype}`;
            const card = document.createElement('div');
            card.className = 'card';
    
            // Header for the collapsible section
            const header = document.createElement('div');
            header.className = 'card-header';
            header.id = `${datatypeId}-header`;
            header.innerHTML = `
                <h6 class="mb-0">
        <a class="btn btn-link d-flex align-items-center" type="button" data-bs-toggle="collapse" data-bs-target="#${datatypeId}" aria-expanded="false" aria-controls="${datatypeId}">
            ${datatype.charAt(0).toUpperCase() + datatype.slice(1)} Operations
            <span class="ms-auto">
                <i class="bi bi-chevron-down"></i>
            </span>
        </a>
    </h6>
            `;
            card.appendChild(header);
    
            // Collapsible body
            const body = document.createElement('div');
            body.className = 'collapse';
            body.id = datatypeId;
            body.setAttribute('aria-labelledby', `${datatypeId}-header`);
            body.setAttribute('data-bs-parent', '#operations-menu');
    
            const list = document.createElement('ul');
            list.className = 'list-group list-group-flush';
    
            operations.forEach(operation => {
                const listItem = document.createElement('li');
                listItem.className = 'list-group-item operation-item';
                listItem.textContent = operation.name;
                listItem.dataset.description = operation.description;
                listItem.dataset.example = operation.example.formula;
                listItem.dataset.formulaKeyword = operation.formula_keyword;
    
                // Single-click: Update description and example
                listItem.addEventListener('click', function () {
                    operationDescription.textContent = operation.description;
                    operationExample.innerHTML = `
        <strong>Formula:</strong> ${operation.example.formula}<br>
        <strong>Columns:</strong> ${JSON.stringify(operation.example.columns)}<br>
        <strong>Result:</strong> ${JSON.stringify(operation.example.result)}
    `;
                });
    
                // Double-click: Append formula keyword to field expression
                listItem.addEventListener('dblclick', function () {
                    fieldExpressionInput.value += operation.formula_keyword + '()';
                });
    
                // Drag-and-drop functionality
                listItem.draggable = true;
                listItem.addEventListener('dragstart', function (event) {
                    event.dataTransfer.setData('text/plain', operation.formula_keyword + '()');
                });
    
                list.appendChild(listItem);
            });
    
            body.appendChild(list);
            card.appendChild(body);
            operationsMenu.appendChild(card);
        }
    
        // Enable drag-and-drop for the field expression textarea
        fieldExpressionInput.addEventListener('dragover', function (event) {
            event.preventDefault();
        });
    
        fieldExpressionInput.addEventListener('drop', function (event) {
            event.preventDefault();
            const droppedText = event.dataTransfer.getData('text/plain');
            
            // Append the dropped text only if it doesn't already exist at the end
            if (!fieldExpressionInput.value.endsWith(droppedText)) {
                fieldExpressionInput.value += droppedText;
            }
        });
    });
    document.addEventListener('DOMContentLoaded', function () {
        const rejectionCriteriaCheckbox = document.getElementById('set-rejection-criteria');
        const rejectionCriteriaContainer = document.getElementById('rejection-criteria-container');
        const inputSchemaDropdown = document.getElementById('input-schema-dropdown');
        const setRejectionButton = document.getElementById('set-rejection-button');
        const rejectionCriteriaList = document.createElement('ul'); // Create a list for rejection criteria
        rejectionCriteriaList.id = 'rejection-criteria-list';
        rejectionCriteriaList.className = 'list-group';
        rejectionCriteriaContainer.appendChild(rejectionCriteriaList);
    
        // Toggle visibility of the rejection criteria container
        rejectionCriteriaCheckbox.addEventListener('change', function () {
            if (this.checked) {
                rejectionCriteriaContainer.style.display = 'block';
                populateInputSchemaDropdown();
            } else {
                rejectionCriteriaContainer.style.display = 'none';
            }
        });
        // Function to populate the rejection criteria list
    
        // Function to populate the dropdown with input schema fields
        function populateInputSchemaDropdown() {
            fetch(`{% url 'get_enrichment_schema_rejection_fields' %}?datasource_id={{ datasource.id }}`, {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                },
            })
                .then(response => response.json())
                .then(data => {
                    inputSchemaDropdown.innerHTML = '';
                    if (data.success && data.fieldnames.length > 0) {
                        data.fieldnames.forEach(fieldname => {
                            const option = document.createElement('option');
                            option.value = fieldname;
                            option.textContent = fieldname;
                            inputSchemaDropdown.appendChild(option);
                        });
                    } else {
                        inputSchemaDropdown.innerHTML = '<option value="">No fields available</option>';
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    inputSchemaDropdown.innerHTML = '<option value="">Error loading fields</option>';
                });
        }
    
        // Function to populate the rejection criteria list
        function populateRejectionCriteriaList() {
            fetch(`{% url 'get_enrichment_rejection_schema' %}?datasource_id={{ datasource.id }}`, {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                },
            })
                .then(response => response.json())
                .then(data => {
                    rejectionCriteriaList.innerHTML = '';
                    if (data.success && data.enrichment_rejection_fields.length > 0) {
                        // Check the checkbox if rejection fields exist
                        rejectionCriteriaCheckbox.checked = true;
                        rejectionCriteriaContainer.style.display = 'block';
    
                        data.enrichment_rejection_fields.forEach(field => {
                            const li = document.createElement('li');
                            li.className = 'list-group-item d-flex justify-content-between align-items-center';
                            li.textContent = field;
                            const deleteButton = document.createElement('button');
                            deleteButton.className = 'btn btn-danger btn-sm';
                            deleteButton.innerHTML = '<i class="fas fa-trash"></i>';
                            deleteButton.addEventListener('click', function () {
                                deleteRejectionField(field, li);
                            });
                            li.appendChild(deleteButton);
                            rejectionCriteriaList.appendChild(li);
                        });
                    } else {
                        rejectionCriteriaCheckbox.checked = false;
                        rejectionCriteriaContainer.style.display = 'none';
                        rejectionCriteriaList.innerHTML = '<li class="list-group-item">No rejection criteria set.</li>';
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    rejectionCriteriaList.innerHTML = '<li class="list-group-item">Error loading rejection criteria.</li>';
                });
        }
    
        // Function to delete a rejection field
        function deleteRejectionField(field, listItem) {
            fetch(`{% url 'delete_enrichment_rejection_field' %}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}',
                },
                body: JSON.stringify({ field_name: field,datasource_id: '{{ datasource.id }}' }),
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        listItem.remove();
                        alert(`Rejection field "${field}" deleted successfully.`);
                    } else {
                        alert(`Error deleting rejection field: ${data.error}`);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Failed to delete rejection field. Please try again.');
                });
        }
        populateInputSchemaDropdown();
        // Handle the "Set Condition" button click
        setRejectionButton.addEventListener('click', function () {
            const selectedField = inputSchemaDropdown.value;
            console.log("Selected field:", selectedField);
            if (selectedField) {
                fetch(`{% url 'update_enrichment_rejection_schema' %}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}',
                    },
                    body: JSON.stringify({ field_name: selectedField,datasource_id: '{{ datasource.id }}'}),
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            const li = document.createElement('li');
                            li.className = 'list-group-item d-flex justify-content-between align-items-center';
                            li.textContent = selectedField;
                            const deleteButton = document.createElement('button');
                            deleteButton.className = 'btn btn-danger btn-sm';
                            deleteButton.innerHTML = '<i class="fas fa-trash"></i>';
                            deleteButton.addEventListener('click', function () {
                                deleteRejectionField(selectedField, li);
                            });
                            li.appendChild(deleteButton);
                            rejectionCriteriaList.appendChild(li);
                            alert(`Rejection criteria set: ${selectedField} must not be null.`);
                        } else {
                            alert(`Error setting rejection criteria: ${data.error}`);
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Failed to set rejection criteria. Please try again.');
                    });
            } else {
                alert('Please select a field to set the rejection criteria.');
            }
        });
    
        // Populate the rejection criteria list on page load
        populateRejectionCriteriaList();
    });
    document.addEventListener('DOMContentLoaded', async function () {
        
        const lookupDatastoresList = document.getElementById('lookup-datastores');
    const createdFields = document.getElementById('created-fields');
    const createdFieldsBody = document.getElementById('created-fields-body');
    const fieldExpressionInput = document.getElementById('field-expression');

    // Function to fetch datastores having relationships with the datasource
    async function fetchLookupDatastores() {
        try {
            const response = await fetch(`{% url 'get_relationships' %}?datasource_id={{ datasource.id }}`, {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                },
            });

            if (!response.ok) {
                throw new Error(`Error: ${response.statusText}`);
            }

            const data = await response.json();
            if (data.success && data.relationships.length > 0) {
                return data.relationships; // Return relationships for dropdown population
            } else {
                return [];
            }
        } catch (error) {
            console.error('Error fetching lookup datastores:', error);
            return [];
        }
    }

    // Function to populate the lookup datastores list
    async function populateLookupDatastores() {
        relationships = await fetchLookupDatastores();
        lookupDatastoresList.innerHTML = ''; // Clear existing datastores

        relationships.forEach(relationship => {
            const datastoreItem = document.createElement('li');
            datastoreItem.className = 'list-group-item';

            // Create a collapsible section for each datastore
            datastoreItem.innerHTML = `
                <div>
                    <strong>${relationship.datastore_name}</strong> (Key: ${relationship.datastore_key})
                </div>
                <ul class="list-group mt-2">
                    ${relationship.columns.map(column => `
                        <li class="list-group-item lookup draggable" draggable="true" data-internal-name="${relationship.datastore_internal_name}" data-column-name="${column.name}" data-datatype="${column.data.datatype}" data-value="${column.data.result}">
                            <span class="datatype-box ${column.data.datatype.toLowerCase()}">${column.data.datatype}</span>
                            <strong>${column.name}</strong>
                            <span style="font-size: 0.9em; font-style: italic; color: grey;">(Ex: ${column.data.result})</span>
                        </li>
                    `).join('')}
                </ul>
            `;

            // Add drag-and-drop functionality to each column
            const columnItems = datastoreItem.querySelectorAll('.lookup.draggable');
            columnItems.forEach(item => {
                item.addEventListener('dragstart', function (event) {
                    const columnData = {
                        name: item.dataset.columnName,
                        datatype: item.dataset.datatype,
                        value: item.dataset.value,
                        formula: '$profile.'+item.dataset.internalName+'.'+item.dataset.columnName // Simple formula using the column name
                    };
                    event.dataTransfer.setData('application/json', JSON.stringify(columnData)); // Set data as JSON
                });

                item.addEventListener('dblclick', function () {
                    fieldExpressionInput.value += '$profile.'+item.dataset.internalName+'.'+item.dataset.columnName;
                });
            });

            lookupDatastoresList.appendChild(datastoreItem);
        });
    }

    
        // Populate the lookup datastores on page load
        populateLookupDatastores();
    });
    document.addEventListener('DOMContentLoaded', function () {
        const skipCampaignProcessingCheckbox = document.getElementById('skip-campaign-processing');
    
        // Handle checkbox state change
        skipCampaignProcessingCheckbox.addEventListener('change', async function () {
            const isChecked = this.checked;
            console.log(`Skip Campaign Processing ${isChecked ? 'enabled' : 'disabled'}.`);
    
            try {
                const response = await fetch(`{% url 'update_skip_campaign_processing_state' %}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}',
                    },
                    body: JSON.stringify({
                        datasource_id: '{{ datasource.id }}',
                        skip_campaign_processing: isChecked,
                    }),
                });
    
                if (!response.ok) {
                    throw new Error(`Error: ${response.statusText}`);
                }
    
                const data = await response.json();
                if (data.success) {
                    alert(`Skip Campaign Processing ${isChecked ? 'enabled' : 'disabled'} successfully.`);
                } else {
                    alert(`Error updating Skip Campaign Processing: ${data.error}`);
                }
            } catch (error) {
                console.error('Error updating Skip Campaign Processing:', error);
                alert('Failed to update Skip Campaign Processing. Please try again.');
            }
        });
    
        // Optionally, fetch the current state from the backend and set the checkbox state
        fetch(`{% url 'get_skip_campaign_processing_state' %}?datasource_id={{ datasource.id }}`, {
            method: 'GET',
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
            },
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    skipCampaignProcessingCheckbox.checked = data.skip_campaign_processing;
                } else {
                    console.error('Error fetching skip campaign processing state:', data.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
            });
    });
</script>
{% endblock %}

