{% extends "usex_app/index.html" %}
{% block title %}
Parser - Matcha
{% endblock %}
{% block style %}
<!-- Awesomplete CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/awesomplete/1.1.5/awesomplete.min.css">

<!-- Awesomplete JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/awesomplete/1.1.5/awesomplete.min.js"></script>
<script src="https://code.jquery.com/jquery-3.7.1.slim.min.js" integrity="sha256-kmHvs0B+OpCW5GVHUNjv9rOmY0IvSIRcf7zGUDTDQM8=" crossorigin="anonymous"></script>
<link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>

<style>
    .btn-link {
        text-decoration: none;
        color: #007bff;
    }

    .btn-link:hover {
        text-decoration: underline;
    }

    .bi-chevron-down {
        transition: transform 0.3s ease;
    }

    .collapse.show + .card-header .bi-chevron-down {
        transform: rotate(180deg); /* Rotate arrow when expanded */
    }
</style>
<style>
    .card-body {
        min-height: 400px; /* Set minimum height for scrollable areas */
        max-height: 400px; /* Set maximum height for scrollable areas */
        overflow-y: auto; /* Enable vertical scrolling */
    }

    .datatype-box {
        display: inline-block;
        padding: 2px 6px;
        margin-left: 8px;
        border-radius: 4px;
        font-size: 0.85em;
        font-style: italic;
        color: white; /* Default text color */
    }

    .str {
        background-color: #007bff; /* Blue for strings */
    }

    .int {
        background-color: #28a745; /* Green for integers */
    }

    .float {
        background-color: #ffc107; /* Yellow for floats */
    }

    .bool {
        background-color: #17a2b8; /* Teal for booleans */
    }

    .datetime {
        background-color: #6c757d; /* Grey for dates */
    }
</style>
{% endblock %}

{% block content %}

<div class="container mt-4">
    <h2>Aggregation for {{ datasource.name }}</h2>
    <p> {{ datasource.description }}</p>
    <p><strong>Type:</strong> {{ datasource.datasource_type }}</p>

    <div class="row">
        <!-- Left Column: Query Result Columns -->
        <div class="col-md-3" style="max-height: 400px; overflow-y: auto;">
            <div class="card">
                <div class="card-header">
                    <h5>Parsing schema</h5>
                </div>
                <div class="card-body" style="max-height: 300px; overflow-y: auto;">
                    <ul id="query-columns" class="list-group">
                        <!-- Dynamically populated list of columns -->
                    </ul>
                </div>
            </div>
            <!-- Lookup Datastore Section -->
            
        <div class="card mt-4">
            <div class="card-header">
                <h5>Lookup Datastore</h5>
            </div>
            <div class="card-body" style="max-height: 300px; overflow-y: auto;">
                <ul id="lookup-datastores" class="list-group">
                    <!-- Dynamically populated list of datastores -->
                </ul>
            </div>
        </div>
        </div>
        
        <!-- Middle Column: Calculation Field Area -->
        <div class="col-md-6">
            <div id="calculated-field-area" class="card mb-4">
                <div class="card-header">
                    <h5>Create Aggregation Field</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <!-- Left Column: Scrollable Operations Menu -->
                        <div class="col-md-4">
                            <div class="mb-3" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px;">
                                <label class="form-label">Select Operation</label>
                                <div id="operations-menu" class="accordion" role="tablist">
                                    <!-- Dynamically populated collapsible list -->
                                </div>
                            </div>
                        </div>

                        <!-- Middle Column: Operation Details -->
                        <div class="col-md-4">
                            <div id="operation-details" class="mt-3">
                                <h6>Operation Details</h6>
                                <p id="operation-description"><strong>Description:</strong> <span></span></p>
                                <p id="operation-example"><strong>Example:</strong> <span></span></p>
                            </div>
                        </div>

                        <!-- Right Column: Field Name and Expression -->
                        <div class="col-md-4">
                            <form id="calculated-field-form">
                                <div class="mb-3">
                                    <label for="field-name" class="form-label">Field Name</label>
                                    <input type="text" id="field-name" class="form-control" placeholder="Enter field name" required>
                                </div>
                                <div class="mb-3">
                                    <label for="field-expression" class="form-label">Field Expression</label>
                                    <textarea id="field-expression" class="form-control awesomplete" rows="3" data-multiple placeholder="Drag and drop column names here or type manually" required></textarea>
                                </div>
                                <div class="mb-3">
                                    <label for="tuple-filter" class="form-label">Tuple Filter</label>
                                    <textarea id="tuple-filter" class="form-control awesomplete" rows="3" data-multiple placeholder="Drag and drop column names here or type manually" required></textarea>
                                </div>
                                <div class="mb-3">
                                    <label for="aggregation-type" class="form-label">Aggregation Type</label>
                                    <select id="aggregation-type" name="aggregation_type" class="form-select" required>
                                        <option value="sum">Sum</option>
                                        
                                        <option value="average">Average</option>
                                    </select>
                                </div>
                                <div class="mb-3">
                                    <label for="group-by-fields" class="form-label">Group By Fields</label>
                                    <select id="group-by-fields" name="group_by_fields" class="form-select select2" multiple required>
                                        <!-- Options dynamically populated from parsing schema and lookup tables -->
                                    </select>
                                </div>
                                
                                <button type="button" id="save-calculated-field" class="btn btn-primary">Save Field</button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Column: Created Fields -->
        <div class="col-md-3">
            <div class="card">
                <div class="card-header">
                    <h5>Aggregations </h5>
                </div>
                <div id='created-fields-body' class="card-body" style="max-height: 400px; overflow-y: auto;">
                    <ul id="created-fields" class="list-group">
                        <!-- Dynamically populated list of created fields -->
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="schemaDifferenceModal" tabindex="-1" aria-labelledby="schemaDifferenceModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="schemaDifferenceModalLabel">Schema Difference</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <h6>Stored Schema:</h6>
                <pre id="stored-schema-display" style="background-color: #f8f9fa; padding: 10px; border-radius: 5px;"></pre>
                <h6>Current Schema:</h6>
                <pre id="current-schema-display" style="background-color: #f8f9fa; padding: 10px; border-radius: 5px;"></pre>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" id="update-schema-button" class="btn btn-primary">Update Schema</button>
            </div>
        </div>
    </div>
</div>


<script>
    
    document.addEventListener('DOMContentLoaded', function () {
        const queryColumns = document.getElementById('query-columns');
        const columnDatatypes = document.getElementById('column-datatypes');
        const firstRecordValues = document.getElementById('first-record-values');
        const createdFields = document.getElementById('created-fields');
        const createdFieldsBody = document.getElementById('created-fields-body');
        
        const saveCalculatedFieldButton = document.getElementById('save-calculated-field');
        const fieldNameInput = document.getElementById('field-name');
        const fieldExpressionInput = document.getElementById('field-expression');
        const tupleFilterInput = document.getElementById('tuple-filter');
        const aggregationTypeSelect = document.getElementById('aggregation-type');
        // Function to fetch query dataset from the backend
        const groupByFieldsDropdown = document.getElementById('group-by-fields');
        const groupByFieldsDropdownjq = $('#group-by-fields');
        
        async function fetchParsingDataset() {
            try {
                const response = await fetch("{% url 'fetch_query_dataset' datasource.id %}", {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Error: ${response.statusText}`);
                }

                const data = await response.json();
                if (data.success) {
                    return data; // Return the dataset
                } else {
                    alert(`Error: ${data.error}`);
                    return null;
                }
            } catch (error) {
                console.error('Error fetching query dataset:', error);
                alert('Failed to fetch query dataset. Please try again.');
                return null;
            }
        }
        let dataset = null;
        // Handle "Get Input Schema" button click
        let relationships =null;
        
        
        async function fetchLookupDatastores_init() {
            try {
                const response = await fetch(`{% url 'get_relationships' %}?datasource_id={{ datasource.id }}`, {
                    method: 'GET',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                    },
                });
    
                if (!response.ok) {
                    throw new Error(`Error: ${response.statusText}`);
                }
    
                const data = await response.json();
                if (data.success && data.relationships.length > 0) {
                    relationships =  data.relationships; // Return relationships for dropdown population
                } else {
                    throw new Error(`Error: ${data.error}`);
                }
            } catch (error) {
                console.error('Error fetching lookup datastores:', error);
                alert('Failed to fetch query dataset. Please try again.');
                return null;
                
            }
        }
        async function populateGroupByFields() {
            // Fetch parsing schema fields and lookup fields
            const parsingSchemaFields = Object.keys(dataset.parsing_schema || {});
            const lookupFields = relationships.flatMap(relationship =>
                relationship.columns.map(column => ({
                    name: column.name,
                    internalName: relationship.datastore_internal_name,
                    datastoreName: relationship.datastore_name
                }))
            );
    
            // Clear existing options
            groupByFieldsDropdown.innerHTML = '';
    
            // Add Parsing Schema Fields as an optgroup
            const parsingSchemaOptGroup = document.createElement('optgroup');
            parsingSchemaOptGroup.label = 'Parsing Schema Fields';
            parsingSchemaFields.forEach(field => {
                const option = document.createElement('option');
                option.value = '$feed.'+field;
                option.textContent = field;
                parsingSchemaOptGroup.appendChild(option);
            });
            groupByFieldsDropdown.appendChild(parsingSchemaOptGroup);
    
            // Add Lookup Fields as optgroups grouped by datastore
            const lookupFieldsGrouped = lookupFields.reduce((groups, field) => {
                if (!groups[field.datastoreName]) {
                    groups[field.datastoreName] = [];
                }
                groups[field.datastoreName].push(field);
                return groups;
            }, {});
    
            Object.entries(lookupFieldsGrouped).forEach(([datastoreName, fields]) => {
                const lookupOptGroup = document.createElement('optgroup');
                lookupOptGroup.label = `Lookup Fields (${datastoreName})`;
                fields.forEach(field => {
                    const option = document.createElement('option');
                    option.value = `$feed.${field.internalName}.${field.name}`;
                    option.textContent = field.name;
                    lookupOptGroup.appendChild(option);
                });
                groupByFieldsDropdown.appendChild(lookupOptGroup);
            });
    
            // Initialize Select2 for enhanced dropdown functionality
            $(groupByFieldsDropdown).select2({
                placeholder: "Select fields to group by",
                allowClear: true,
                width: '100%' // Optional: Adjust width to fit the container
            });
        }
        async function getParsingSchema() {
            // Fetch query dataset
            dataset = await fetchParsingDataset();

            if (!dataset) return;

            
            populateGroupByFields();
            // Populate the query columns list
            queryColumns.innerHTML = '';
            Object.entries(dataset.parsing_schema).forEach(([column,column_data]) => {
                const li = document.createElement('li');
                li.className = 'list-group-item draggable';
                li.textContent = column;
                li.draggable = true;
                

                // Add drag-and-drop functionality
                li.addEventListener('dragstart', function (event) {
                    const columnData = {
                        name: column,
                        datatype: column_data['datatype'],
                        value: column_data['result'],
                        formula:'$feed.'+column
                    };
                    event.dataTransfer.setData('application/json', JSON.stringify(columnData)); // Set data as JSON
                });
                li.addEventListener('dblclick', function () {
                    fieldExpressionInput.value += '$feed.'+column ;
                    
                });
                li.innerHTML = `<span class="datatype-box ${column_data['datatype'].toLowerCase()}">${column_data['datatype']}</span> 
                                <strong>${column}</strong> 
                                <span style="font-size: 0.9em; font-style: italic; color: grey;">(Ex: ${column_data['result']})</span>`;

                queryColumns.appendChild(li);
            });
            // Populate the "Created Fields" list based on aggregation_schema
    createdFields.innerHTML = ''; // Clear existing fields
    const aggregationSchema = dataset.aggregation_schema || {};
    console.log("Pre-aggregation schema:", aggregationSchema);
    Object.entries(aggregationSchema).forEach(([fieldName, fieldData]) => {
        console.debug("Field Data:", fieldData);
        const { formula, result, datatype,aggregate_type,tuple_filter,retention_window,group_by_fields } = fieldData;
        
        console.debug("Field Name:", fieldName);
        console.debug("Field Formula:", formula);
        console.debug("Field Result:", result); 
        console.debug("Field Datatype:", datatype);
        console.debug("Field Aggregate Type:", aggregate_type);
        console.debug("Field Retention Window:", retention_window);
        console.debug("Field Group By Fields:", group_by_fields);
        console.debug("Field Tuple Filter:", tuple_filter);
        // Add the field to the "Created Fields" list
        addFieldToCreatedFields(fieldName, formula, datatype, result,aggregate_type,retention_window,group_by_fields,tuple_filter);
    });

          
            
        }
         fetchLookupDatastores_init();
        getParsingSchema();
        function addFieldToCreatedFields(fieldName, fieldExpression, fieldDatatype, fieldValue,aggregate_type,retention_window,groups_by_fields,tuple_filter) {
            console.debug("Adding field to created fields:", fieldName, fieldExpression, fieldDatatype, fieldValue,aggregate_type,retention_window,groups_by_fields);
            const li = document.createElement('li');
            li.className = 'list-group-item d-flex justify-content-between align-items-center';
            li.dataset.formula = fieldExpression; // Store the formula in a data attribute
            li.dataset.fieldName = fieldName; // Store the field name in a data attribute
            li.dataset.fieldDatatype = fieldDatatype; // Store the field datatype in a data attribute
            li.dataset.aggregateType = aggregate_type; // Store the aggregate type in a data attribute
            li.dataset.retentionWindow = retention_window; // Store the retention window in a data attribute
            console.debug("Groups By Fields:", groups_by_fields);
            li.dataset.groupsByFields = groups_by_fields.join(','); // Store the group by fields in a data attribute
            li.dataset.tupleFilter = tuple_filter; // Store the tuple filter in a data attribute
            li.innerHTML = `
                <div>
                    <span class="datatype-box ${fieldDatatype.toLowerCase()}">${fieldDatatype}</span>
                    <strong>${fieldName}</strong>: ${aggregate_type}(${fieldExpression})   ${groups_by_fields ? `grouped by ${groups_by_fields.join(', ')}`: ''} ${tuple_filter ? `with filter ${tuple_filter}` : ''}
                    <span style="font-size: 0.9em; font-style: italic; color: grey;">(Result: ${fieldValue})</span>
                </div>
                <button class="btn btn-danger btn-sm delete-field-btn" title="Delete Field">
                    <i class="fas fa-trash"></i>
                </button>
                
            `;
            

            
    
            // Add delete functionality
            li.querySelector('.delete-field-btn').addEventListener('click', async function () {
                const confirmDelete = confirm(`Are you sure you want to delete the field "${fieldName}"?`);
                if (confirmDelete) {
                    try {
                        // Send request to delete the field from aggregation_schema
                        const response = await fetch("{% url 'delete_aggregation_field' datasource.id %}", {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ field_name: fieldName })
                        });
        
                        if (!response.ok) {
                            throw new Error(`Error: ${response.statusText}`);
                        }
        
                        const data = await response.json();
                        if (data.success) {
                            // Remove the field from the UI
                            li.remove();
                            alert(`Field "${fieldName}" deleted successfully.`);
                            location.reload(); // Reload the page to reflect changes
                            // Disable the calculated field inputs if the deleted field is currently being edited
                if (fieldNameInput.value === fieldName) {
                    fieldNameInput.value = '';
                    fieldExpressionInput.value = '';
                    tupleFilterInput.value = '';
                    groupByFieldsDropdown.value = ''; // Clear the group by fields selection
                    aggregationTypeSelect.value = 'sum'; // Reset to default aggregation type
                    fieldNameInput.disabled = true;
                    fieldExpressionInput.disabled = true;
                    tupleFilterInput.disabled = true;   
                    groupByFieldsDropdown.disabled = true;
                    aggregationTypeSelect.disabled = true;


                    // Reset the "Save Field" button
                    saveCalculatedFieldButton.textContent = "Save Field";
                    saveCalculatedFieldButton.classList.add("btn-primary");
                    saveCalculatedFieldButton.classList.remove("btn-warning");
                }
                        } else {
                            alert(`Error deleting field: ${data.error}`);
                        }
                    } catch (error) {
                        console.error('Error deleting field:', error);
                        alert('Failed to delete field. Please try again.');
                    }
                }
            });
        
            createdFields.appendChild(li);
        }

        
        
        

        // Enable drag-and-drop for the field expression textarea
        fieldExpressionInput.addEventListener('dragover', function (event) {
            event.preventDefault();
        });

        fieldExpressionInput.addEventListener('drop', function (event) {
            event.preventDefault();
            const formula = JSON.parse(event.dataTransfer.getData('application/json'))['formula']
            console.debug("Field Expression Drop Event dropped text:", formula);
            
            
            // Append the dropped text only if it doesn't already exist at the end
            if (!fieldExpressionInput.value.endsWith(formula)) {
                fieldExpressionInput.value += formula;
            }
        });
        // Enable drag-and-drop for the "Tuple Filter" textarea
    tupleFilterInput.addEventListener('dragover', function (event) {
        event.preventDefault();
    });

    tupleFilterInput.addEventListener('drop', function (event) {
        event.preventDefault();
        const droppedText = JSON.parse(event.dataTransfer.getData('application/json'))

        console.debug("Tuple Filter Drop Event dropped text:", droppedText.formula);

        tupleFilterInput.value += droppedText.formula;
    });
        // Handle "Save Calculated Field" button click
                
        saveCalculatedFieldButton.addEventListener('click', async function () {
            const fieldName = fieldNameInput.value.trim();
            const fieldExpression = fieldExpressionInput.value.trim();
            const tupleFilter = tupleFilterInput.value.trim();
            const groupByFields = Array.from(groupByFieldsDropdown.selectedOptions).map(option => option.value);
            const aggregationType = aggregationTypeSelect.value;
            const columnValues = {}
            console.debug("Dataset:", dataset);
            console.debug('relationships:', relationships);
            Object.entries(dataset.parsing_schema).forEach(([column,column_data]) => {
                //console.debug("Column Data:", column_data);
                //console.debug("Column:", column);
                columnValues['$feed.'+column.toLowerCase()] = column_data['result']; // Assuming dataset contains column values
            });
            relationships.forEach(relationship => {
                console.log(`Datastore Name: ${relationship.datastore_name}`);
                //console.log(`Datastore Key: ${relationship.datastore_key}`);
                
                // Loop through columns in the relationship
                relationship.columns.forEach(column => {
                    console.log(`Column Name: ${column.name}`);
                    console.log(`Column Datatype: ${column.data.datatype}`);
                    console.log(`Column Value: ${column.data.result}`);
                    columnValues[`_${relationship.datastore_internal_name.toLowerCase()}.`+column.name.toLowerCase()] = column.data.result; // Assuming dataset contains column values
                });
            });
            const mode = saveCalculatedFieldButton.textContent === "Update Field" ? "update" : "create";
        
            if (!fieldName || !fieldExpression) {
                alert('Both field name and expression are required.');
                return;
            }
        
            if (mode !== "update") {
                // Check if the field name already exists in the "Created Fields" list
                const existingField = Array.from(createdFields.children).find(
                    (item) => item.querySelector('strong').textContent === fieldName
                );
        
                if (existingField) {
                    alert(`Field name "${fieldName}" already exists. Please choose a different name.`);
                    return;
                }
            }
        
            // Prepare the payload with field expression and column values
            const payload = {
                field_expression: fieldExpression,
                column_values: columnValues // Assuming dataset contains column values
                , field_name: fieldName,
                tuple_filter: tupleFilter,
                group_by_fields: groupByFields, 
                aggregation_type: aggregationType,

            };
        
            try {
                // Send the payload to the API
                const response = await fetch("{% url 'aggregation_interpreter_api' %}", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: JSON.stringify(payload)
                });
        
                if (!response.ok) {
                    throw new Error(`Error: ${response.statusText}`);
                }
        
                const data = await response.json();
                if (data.success) {
                    console.debug("Calculated Field Response:", data);
                    // Extract the returned value and datatype
                    const calculatedValue = data.result.value;
                    const calculatedDatatype = data.result.datatype;
        
                    if (mode === "update") {
                        // Update the existing field in the "Created Fields" list
                        const existingField = Array.from(createdFields.children).find(
                            (item) => item.querySelector('strong').textContent === fieldName
                        );
        
                        if (existingField) {
                            existingField.dataset.formula = fieldExpression; // Update the formula in the dataset
                            existingField.className = 'list-group-item d-flex justify-content-between align-items-center';
                            existingField.dataset.formula = fieldExpression; // Store the formula in a data attribute
                            existingField.dataset.fieldName = fieldName; // Store the field name in a data attribute
                            existingField.dataset.fieldDatatype = calculatedDatatype; // Store the field datatype in a data attribute
                            existingField.dataset.aggregateType = aggregationType; // Store the aggregate type in a data attribute
                            existingField.dataset.retentionWindow = 1; // Store the retention window in a data attribute
                            console.debug("Groups By Fields(Update):", groupByFields);
                            existingField.dataset.groupsByFields = groupByFields.join(','); // Store the group by fields in a data attribute
                            existingField.dataset.tupleFilter = tupleFilter; // Store the tuple filter in a data attribute
                            existingField.innerHTML = `
                            <div>
                                <span class="datatype-box ${calculatedDatatype.toLowerCase()}">${calculatedDatatype}</span>
                                <strong>${fieldName}</strong>: ${aggregationType}(${fieldExpression})   ${groupByFields ? `grouped by ${groupByFields.join(', ')}`: ''} ${tupleFilter ? `with filter ${tupleFilter}` : ''}
                                <span style="font-size: 0.9em; font-style: italic; color: grey;">(Result: ${calculatedValue})</span>
                            </div>
                            <button class="btn btn-danger btn-sm delete-field-btn" title="Delete Field">
                                <i class="fas fa-trash"></i>
                            </button>
                            
                        `;
                            
                        }
                        // Add delete functionality
                        existingField.querySelector('.delete-field-btn').addEventListener('click', async function () {
                const confirmDelete = confirm(`Are you sure you want to delete the field "${fieldName}"?`);
                if (confirmDelete) {
                    try {
                        // Send request to delete the field from aggregation_schema
                        const response = await fetch("{% url 'delete_aggregation_field' datasource.id %}", {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ field_name: fieldName })
                        });
        
                        if (!response.ok) {
                            throw new Error(`Error: ${response.statusText}`);
                        }
        
                        const data = await response.json();
                        if (data.success) {
                            // Remove the field from the UI
                            existingField.remove();
                            alert(`Field "${fieldName}" deleted successfully.`);
                            // Disable the calculated field inputs if the deleted field is currently being edited
                if (fieldNameInput.value === fieldName) {
                    fieldNameInput.value = '';
                    fieldExpressionInput.value = '';
                    tupleFilterInput.value = '';
                    groupByFieldsDropdown.value = ''; // Clear the group by fields selection
                    aggregationTypeSelect.value = 'sum'; // Reset to default aggregation type
                    fieldNameInput.disabled = true;
                    fieldExpressionInput.disabled = true;
                    tupleFilterInput.disabled = true;
                    groupByFieldsDropdown.disabled = true;
                    aggregationTypeSelect.disabled = true;

                    // Reset the "Save Field" button
                    saveCalculatedFieldButton.textContent = "Save Field";
                    saveCalculatedFieldButton.classList.add("btn-primary");
                    saveCalculatedFieldButton.classList.remove("btn-warning");
                }
                        } else {
                            alert(`Error deleting field: ${data.error}`);
                        }
                    } catch (error) {
                        console.error('Error deleting field:', error);
                        alert('Failed to delete field. Please try again.');
                    }
                }
            });
                    } else {
                        // Add the new field to the "Created Fields" list
                        addFieldToCreatedFields(fieldName, fieldExpression, calculatedDatatype, calculatedValue,
                            aggregationType, 30, groupByFields,tupleFilter);
                    }
        
                    // Send the formula data to the backend to update the aggregation_schema
                    const updateResponse = await fetch("{% url 'update_aggregation_schema' datasource.id %}", {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({
                            field_name: fieldName,
                            formula: fieldExpression,
                            result: calculatedValue,
                            datatype: calculatedDatatype,
                             field_name: fieldName,
                            tuple_filter: tupleFilter,
                            group_by_fields: groupByFields, 
                            aggregation_type: aggregationType,
                        })
                    });
        
                    if (!updateResponse.ok) {
                        throw new Error(`Error: ${updateResponse.statusText}`);
                    }
        
                    const updateData = await updateResponse.json();
        
                    if (!updateData.success) {
                        alert(`Error updating aggregation_schema: ${updateData.error}`);
                    }
        
                    // Clear the form inputs
                    fieldNameInput.value = '';
                    fieldExpressionInput.value = '';
                    tupleFilterInput.value = '';
                    groupByFieldsDropdownjq.val('') ; // Clear the group by fields selection
                    groupByFieldsDropdownjq.trigger('change');
                    aggregationTypeSelect.value = 'sum'; // Reset to default aggregation type

                    
                } else {
                    alert(`Error: ${data.error}`);
                }
            } catch (error) {
                console.error('Error saving calculated field:', error);
                alert('Failed to save calculated field. Please try again.');
            }
        
            if (mode === "update") {
                // Reset the button to "Save" mode
                saveCalculatedFieldButton.textContent = "Save Field";
                saveCalculatedFieldButton.classList.add("btn-primary");
                saveCalculatedFieldButton.classList.remove("btn-warning");
            }
        });
        createdFields.addEventListener('click', function (event) {
            const clickedItem = event.target.closest('.list-group-item'); // Get the clicked list item
            if (clickedItem) {
                const fieldName = clickedItem.querySelector('strong').textContent; // Extract the field name
                const fieldFormula = clickedItem.dataset.formula; // Extract the formula stored in the dataset
                const fieldDatatype = clickedItem.dataset.fieldDatatype; // Extract the datatype
                const aggregateType = clickedItem.dataset.aggregateType; // Extract the aggregate type
                const retentionWindow = clickedItem.dataset.retentionWindow; // Extract the retention window
                const groupsByFields = clickedItem.dataset.groupsByFields.split(','); // Extract the group
                const tupleFilter = clickedItem.dataset.tupleFilter || ''; // Extract the tuple filter if available
                
                // Populate the calculated area inputs
                fieldNameInput.value = fieldName;
                fieldExpressionInput.value = fieldFormula;
                tupleFilterInput.value = tupleFilter; // Clear the tuple filter input
                groupByFieldsDropdownjq.val(groupsByFields); // Clear the group by fields selection    
                groupByFieldsDropdownjq.trigger('change');
                aggregationTypeSelect.value = aggregateType; // Set the aggregation type

        
                // Switch the button to "Update" mode
                saveCalculatedFieldButton.textContent = "Update Field";
                saveCalculatedFieldButton.classList.add("btn-warning"); // Change button style to indicate update
                saveCalculatedFieldButton.classList.remove("btn-primary");
        
                
            }
        });
    });
    // Handle clicks on created fields

    
    document.addEventListener('DOMContentLoaded', async function () {
        const operationsMenu = document.getElementById('operations-menu');
        const operationDescription = document.getElementById('operation-description').querySelector('span');
        const operationExample = document.getElementById('operation-example').querySelector('span');
        const fieldExpressionInput = document.getElementById('field-expression');
        const operationsData = await fetch('/api/get_operations').then(response => response.json());
        // Example operations data (replace this with data fetched from the backend)
        const operationsData1 = {
            string: [
                {
                    name: "Concatenate",
                    description: "Combine two or more strings.",
                    formula_keyword: "CONCATENATE",
                    example: "concatenate(col1, ' ', col2)"
                },
                {
                    name: "Substring",
                    description: "Extract a portion of a string.",
                    formula_keyword: "SUBSTRING",
                    example: "substring(col1, 0, 5)"
                }
            ],
            integer: [
                {
                    name: "Add",
                    description: "Add two integers.",
                    formula_keyword: "ADD",
                    example: "add(col1, col2)"
                },
                {
                    name: "Subtract",
                    description: "Subtract one integer from another.",
                    formula_keyword: "SUBTRACT",
                    example: "subtract(col1, col2)"
                }
            ]
            // Add more datatypes and operations here
        };
        // Collect all formula keywords for autocomplete
        const formulaKeywords = [];
        for (const operations of Object.values(operationsData)) {
            operations.forEach(operation => {
                formulaKeywords.push(operation.formula_keyword);
            });
        }
        // Initialize Awesomplete
        new Awesomplete(fieldExpressionInput, {
            list: formulaKeywords, // Provide the list of keywords
            minChars: 1, // Start suggesting after 1 character
            autoFirst: true, // Automatically highlight the first suggestion
            filter: function(text, input) {
                return Awesomplete.FILTER_CONTAINS(text, input.match(/[^\(]*$/)[0]);
            },
        
            item: function(text, input) {
                return Awesomplete.ITEM(text, input.match(/[^\(]*$/)[0]);
            },
        
            replace: function(text) {
                var before = this.input.value.match(/^.+\(\s*|/)[0];
                this.input.value = before + text + "( ";
                
            }
        });
        // Populate the collapsible operations menu
        for (const [datatype, operations] of Object.entries(operationsData)) {
            const datatypeId = `datatype-${datatype}`;
            const card = document.createElement('div');
            card.className = 'card';
    
            // Header for the collapsible section
            const header = document.createElement('div');
            header.className = 'card-header';
            header.id = `${datatypeId}-header`;
            header.innerHTML = `
                <h6 class="mb-0">
        <a class="btn btn-link d-flex align-items-center" type="button" data-bs-toggle="collapse" data-bs-target="#${datatypeId}" aria-expanded="false" aria-controls="${datatypeId}">
            ${datatype.charAt(0).toUpperCase() + datatype.slice(1)} Operations
            <span class="ms-auto">
                <i class="bi bi-chevron-down"></i>
            </span>
        </a>
    </h6>
            `;
            card.appendChild(header);
    
            // Collapsible body
            const body = document.createElement('div');
            body.className = 'collapse';
            body.id = datatypeId;
            body.setAttribute('aria-labelledby', `${datatypeId}-header`);
            body.setAttribute('data-bs-parent', '#operations-menu');
    
            const list = document.createElement('ul');
            list.className = 'list-group list-group-flush';
    
            operations.forEach(operation => {
                const listItem = document.createElement('li');
                listItem.className = 'list-group-item operation-item';
                listItem.textContent = operation.name;
                listItem.dataset.description = operation.description;
                listItem.dataset.example = operation.example.formula;
                listItem.dataset.formulaKeyword = operation.formula_keyword;
    
                // Single-click: Update description and example
                listItem.addEventListener('click', function () {
                    operationDescription.textContent = operation.description;
                    operationExample.innerHTML = `
        <strong>Formula:</strong> ${operation.example.formula}<br>
        <strong>Columns:</strong> ${JSON.stringify(operation.example.columns)}<br>
        <strong>Result:</strong> ${JSON.stringify(operation.example.result)}
    `;
                });
    
                // Double-click: Append formula keyword to field expression
                listItem.addEventListener('dblclick', function () {
                    fieldExpressionInput.value += operation.formula_keyword + '()';
                });
    
                // Drag-and-drop functionality
                listItem.draggable = true;
                listItem.addEventListener('dragstart', function (event) {
                    const operationData = {
                        formula: operation.formula_keyword + '()',
                        description: operation.description,
                        example: operation.example
                    };
                    event.dataTransfer.setData('application/json', JSON.stringify(operationData)); // Set data as
                    
                });
    
                list.appendChild(listItem);
            });
    
            body.appendChild(list);
            card.appendChild(body);
            operationsMenu.appendChild(card);
        }
    
        // Enable drag-and-drop for the field expression textarea
        fieldExpressionInput.addEventListener('dragover', function (event) {
            event.preventDefault();
        });
    
        fieldExpressionInput.addEventListener('drop', function (event) {
            event.preventDefault();
            const formula = JSON.parse(event.dataTransfer.getData('application/json'))['formula']
            console.debug("Field Expression Drop Event dropped text:", formula);
            
            
            // Append the dropped text only if it doesn't already exist at the end
            if (!fieldExpressionInput.value.endsWith(formula)) {
                fieldExpressionInput.value += formula;
            }
        });
    });
    
    document.addEventListener('DOMContentLoaded', async function () {
        
        const lookupDatastoresList = document.getElementById('lookup-datastores');
    const createdFields = document.getElementById('created-fields');
    const createdFieldsBody = document.getElementById('created-fields-body');
    const fieldExpressionInput = document.getElementById('field-expression');

    // Function to fetch datastores having relationships with the datasource
    async function fetchLookupDatastores() {
        try {
            const response = await fetch(`{% url 'get_relationships' %}?datasource_id={{ datasource.id }}`, {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                },
            });

            if (!response.ok) {
                throw new Error(`Error: ${response.statusText}`);
            }

            const data = await response.json();
            if (data.success && data.relationships.length > 0) {
                return data.relationships; // Return relationships for dropdown population
            } else {
                return [];
            }
        } catch (error) {
            console.error('Error fetching lookup datastores:', error);
            return [];
        }
    }

    // Function to populate the lookup datastores list
    async function populateLookupDatastores() {
        relationships = await fetchLookupDatastores();
        lookupDatastoresList.innerHTML = ''; // Clear existing datastores

        relationships.forEach(relationship => {
            const datastoreItem = document.createElement('li');
            datastoreItem.className = 'list-group-item';

            // Create a collapsible section for each datastore
            datastoreItem.innerHTML = `
                <div>
                    <strong>${relationship.datastore_name}</strong> (Key: ${relationship.datastore_key})
                </div>
                <ul class="list-group mt-2">
                    ${relationship.columns.map(column => `
                        <li class="list-group-item lookup draggable" draggable="true" data-internal-name="${relationship.datastore_internal_name}" data-column-name="${column.name}" data-datatype="${column.data.datatype}" data-value="${column.data.result}">
                            <span class="datatype-box ${column.data.datatype.toLowerCase()}">${column.data.datatype}</span>
                            <strong>${column.name}</strong>
                            <span style="font-size: 0.9em; font-style: italic; color: grey;">(Ex: ${column.data.result})</span>
                        </li>
                    `).join('')}
                </ul>
            `;

            // Add drag-and-drop functionality to each column
            const columnItems = datastoreItem.querySelectorAll('.lookup.draggable');
            columnItems.forEach(item => {
                item.addEventListener('dragstart', function (event) {
                    const columnData = {
                        name: item.dataset.columnName,
                        datatype: item.dataset.datatype,
                        value: item.dataset.value,
                        formula: '$profile.'+item.dataset.internalName+'.'+item.dataset.columnName // Simple formula using the column name
                    };
                    event.dataTransfer.setData('application/json', JSON.stringify(columnData)); // Set data as JSON
                });

                item.addEventListener('dblclick', function () {
                    fieldExpressionInput.value += '$profile.'+item.dataset.internalName+'.'+item.dataset.columnName;
                });
            });

            lookupDatastoresList.appendChild(datastoreItem);
        });
    }

    
        // Populate the lookup datastores on page load
        populateLookupDatastores();
    });
    
    
</script>
{% endblock %}

